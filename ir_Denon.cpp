#include "IRremote.h"
#include "IRremoteInt.h"

// Reverse Engineered by looking at RAW dumps generated by IRremote.
// Denon uses a range of different timings and protocols... the values here 
// work for my AVR-2106 Amp using the remote control RC-1016.

//==============================================================================
//                    DDDD   EEEEE  N   N   OOO   N   N
//                     D  D  E      NN  N  O   O  NN  N
//                     D  D  EEE    N N N  O   O  N N N
//                     D  D  E      N  NN  O   O  N  NN
//                    DDDD   EEEEE  N   N   OOO   N   N    RC-1016
//==============================================================================

#define BITS          15  // The number of bits in the command

#define BIT_MARK     275  // The length of a Bit:Mark
#define ONE_SPACE   1900  // The length of a Bit:Space for 1's
#define ZERO_SPACE   775  // The length of a Bit:Space for 0's

//+=============================================================================
//
#if SEND_DENON
void  IRsend::sendDenon (unsigned long data,  int nbits)
{
	// Set IR carrier frequency
	enableIROut(38);

	// Data
	for (unsigned long  mask = 1UL << (nbits - 1);  mask;  mask >>= 1) {
		if (data & mask) {
			mark (BIT_MARK);
			space(ONE_SPACE);
		} else {
			mark (BIT_MARK);
			space(ZERO_SPACE);
		}
	}

	// Footer
	mark(BIT_MARK);
    space(0);  // Always end with the LED off
}
#endif

//+=============================================================================
//
#if DECODE_DENON
bool  IRrecv::decodeDenon (decode_results *results)
{
	unsigned long data = 0;  // Somewhere to build our code

	// Check we have the right amount of data
	// gap-measurement (1) + actual bits (2*15) + end space / space for next gap (1)
	if (irparams.rawlen != 1 + (2 * BITS) + 1)
		return false;

	// has no initial Mark+Space - nothing to check for

	int offset = 1; // skip gap reading

	// Read the bits in
	for (offset; offset < irparams.rawlen; offset++) {
		// Each bit looks like: MARK + SPACE_1 -> 1
		//                 or : MARK + SPACE_0 -> 0
		if(offset % 2) {
			if		(!MATCH_MARK(results->rawbuf[offset], BIT_MARK))  	return false;
		} else {
			// IR data is big-endian, so we shuffle it in from the right:
			if      (MATCH_SPACE(results->rawbuf[offset], ONE_SPACE))   data = (data << 1) | 1;
			else if (MATCH_SPACE(results->rawbuf[offset], ZERO_SPACE))  data = (data << 1) | 0;
			else                                                        return false;
		}
	}

	// Success
	results->bits        = BITS;
	results->value       = data;
	results->decode_type = DENON;
	return true;
}
#endif
